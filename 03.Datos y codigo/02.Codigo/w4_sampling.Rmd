---
title: "w4_sampling"
author: "Luis Carlos Guevara"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE, echo = FALSE}
knitr::opts_chunk$set(echo = FALSE)
#install.packages('viridis')
#install.packages('survival')
library(viridis)
library(survival)
library(dplyr)

#data() 
colon <- survival::colon 

```
# Muestreo aleatorio simple

Para realizar un mue streo eficaz, debemos tratar de dar una probabilidad positiva a la selección de todas las unidades de la población, de modo que la muestra sea realmente representativa de la población.

Esto se denomina muestreo probabilístico. Un esquema de muestreo probabilístico se denomina muestreo aleatorio simple, SRS, si da la misma probabilidad de selección para cada miembro de la población.

Existen dos tipos de muestreo aleatorio simple, en función de si seleccionamos a los individuos uno a uno con o sin devolución de los individuos muestreados a la población.

Cuando devolvemos los individuos seleccionados inmediatamente a la población, realizamos un muestreo aleatorio simple con sustitución o SRSWR, y si no devolvemos los individuos muestreados, realizamos un muestreo aleatorio simple sin sustitución o SRSWOR.

# Cómo generar una muestra aleatoria?

En la práctica, utilizamos una serie de números aleatorios adecuada para extraer muestras al azar.\
\
Existen diferentes series de números aleatorios disponibles en libros y ordenadores. En R podemos utilizar fácilmente el comando sample para extraer muestras aleatorias utilizando SRSWR o SRSWOR.

```{r , echo=TRUE}
# Retira duplicados
#table(colon$id)
table(duplicated(colon$id))
colon_unique <- colon[!duplicated(colon$id),]

# Muestra aleatoria simple utilizando la funcion sample
sample(colon_unique$id, size = 100)

# Muestra aleatoria simple con reemplazo 
sample(colon_unique$id, size = 100, replace = TRUE)
table(duplicated(sample(colon$id, size = 100, replace = TRUE)))

# Muestra aleatoria simple sin reemplazo
sample(colon_unique$id, size = 100, replace = FALSE)
table(duplicated(sample(colon_unique$id, size = 100, replace = FALSE)))
```

Hasta el momento, la muestra aleatoria es solo de los números de identificación de las unidades. Es necesario, ahora, vincular esta selección a un subconjunto que contenga las demás variables del conjunto de datos.

```{r , echo=TRUE}
# se asigna las identificaciones a un vector de valores
muestra <- sample(colon_unique$id, size = 100, replace = FALSE)

# se genera un subconjunto de datos únicamente con las observaciones de la muestra
colon_unique_muestra <- colon_unique[colon_unique$id %in% muestra,]
mean(colon_unique_muestra$age)

# Para "anclar" el proceso aleatorio que genera la muestra, es posible utilizar la función "set.seed" antes de generar la muestra.

set.seed(12345)
muestra <- sample(colon_unique$id, size = 100, replace = FALSE)
colon_unique_muestra <- colon_unique[colon_unique$id %in% muestra,]
mean(colon_unique_muestra$age)

```

## Muestra por segmentos o estratos

```{r , echo=TRUE}
table(colon_unique$sex)

strat_sample <- colon_unique %>%
                  group_by(sex) %>%
                  sample_n(size = 100)

table(strat_sample$sex)

## Hombres
set.seed(12345)
muestra_h <- sample(colon_unique$id[colon_unique$sex == 1],
                    size = 100,
                    replace = FALSE)

colon_h <- colon_unique[colon_unique$id %in% muestra_h,]
table(colon_h$sex)

## mujeres
set.seed(12345)
muestra_m <- sample(colon_unique$id[colon_unique$sex == 0],
                    size = 100,
                    replace = FALSE)

colon_m <- colon_unique[colon_unique$id %in% muestra_m,]
table(colon_m$sex)

## Rbind de las muestras individuales

strat_sample <- rbind(colon_m,colon_h)
table(strat_sample$sex)

```

## Muestreos repetidos

```{r , echo=TRUE}
table(colon_unique$sex)

# define una lista en donde guardaremos cada una de las muestras que vamos a generar
lista <- list()
sample_age <- data.frame(sample_id = character(),
                        mean      = numeric(),
                        sd        = numeric(),
                        n         = numeric(),
                        p_50_60   = numeric())

# inicia loop (o bucle). La idea es tomar una muestra aleatoria sin reemplazo 1000 veces.
# para ello utilizamos la estructura de control for

# define el numero de muestras 
n <- 100

# define el tamaño de muestra
sample_size <- 100

for(i in 1:n){
  lista[[i]] <- colon_unique %>%
                  sample_n(size = sample_size)
  
  loop_aux <- data.frame(sample_id = i,
                        mean       = mean(lista[[i]]$age),
                        sd         = sd(lista[[i]]$age),
                        n          = nrow(lista[[i]]),
                        prop       = nrow(lista[[i]][lista[[i]]$age > 49 & lista[[i]]$age < 61,]) / nrow(lista[[i]])
  )
  
  sample_age <- rbind(sample_age,loop_aux)
  rm(loop_aux)
}


round(mean(sample_age$mean),2)
round(mean(colon_unique$age),2)

hist(sample_age$mean)
hist(sample_age$prop)
```

# Estimación por intervalo

```{r , echo=TRUE}

plot(density(colon_unique$age))
shapiro.test(colon_unique$age)

muestra <- sample(colon_unique$id, size = 100, replace = FALSE)
colon_unique_muestra <- colon_unique[colon_unique$id %in% muestra,]

mean_age <- mean(colon_unique_muestra$age)
sd_age   <- sd(colon_unique_muestra$age)

n <- nrow(colon_unique_muestra)
alpha <- 0.05
Ci <- qt(p = alpha/2, df = n-1, lower.tail= FALSE)

lower <- mean_age - (Ci * (sd_age/sqrt(n)))
upper <-  mean_age + (Ci * (sd_age/sqrt(n)))

cat(paste("[",round(lower,5),round(upper,5),"]"))

t.test(colon_unique_muestra$age)$"conf.int"


lista_i <- list()
sample_i <- data.frame(sample_id  = character(),
                       lower      = numeric(),
                       upper      = numeric(),
                       mean       = numeric(),
                       sd         = numeric(),
                       n          = numeric())
n <- 100
alpha <- 0.05
Ci <- qt(p = alpha/2, df = n-1, lower.tail= FALSE)
sample_size <- 100

for(i in 1:n){
  lista_i[[i]] <- colon_unique %>%
                  sample_n(size = sample_size)
  
  loop_aux  <- data.frame(sample_id  = i,
                          lower      = mean(lista[[i]]$age) - (Ci * (sd(lista[[i]]$age)/sqrt(n))),
                          upper      = mean(lista[[i]]$age) + (Ci * (sd(lista[[i]]$age)/sqrt(n))),
                          mean       = mean(lista[[i]]$age),
                          sd         = sd(lista[[i]]$age),
                          n          = nrow(lista[[i]])
  )
  
  sample_i <- rbind(sample_i,loop_aux)
  rm(loop_aux)
}

sample_i$contenido <-  mean(colon_unique$age) > sample_i$lower & mean(colon_unique$age) <  sample_i$upper

library(ggplot2)
ggplot(sample_i, aes(sample_id, mean)) +        # ggplot2 plot with confidence intervals
  geom_point() +
  geom_errorbar(aes(ymin = lower, ymax = upper)) +
  geom_hline(yintercept = mean(colon_unique$age), linetype = "dashed", color = "red")


```


```{r}
install.packages("lsr")


```

# Pruebas de hipotesis

El peso medio de todos los habitantes de la ciudad Bogotá es de 168 lbs.

Una nutricionista cree que la media real es diferente. Ha medido el peso de 36 personas y ha hallado que la media es de 169,5 libras, con una desviación típica de 3,9. (a) Enuncie las hipótesis nula y alternativa. (b) Con un nivel de confianza del 95%, ¿hay pruebas suficientes para descartar la hipótesis nula? (Utilice el método del valor p)

```{r}
# H0: mu = 168
# H1: mu != 168

y_mu <- 168
y_bar <- 169.5
s <- 3.9
n <- 36
gl = n - 1
confidence <- 0.95
alpha <- 1 - confidence

Z_stat <- (169.5 - 168) / (s/sqrt(n))

# Método de valores críticos ---

## En este ejemplo estamos abordando una prueba de dos colas
# Queremos definir el valor Z asociado al nivel de significancia de 0.025 en cada una de las dos colas. 1 - 0.025 (0.975) es el área acumula a la izquierda del punto z positivo que nos interesa, que n este caso es 1.96

z1 <- qnorm(0.975)
z2 <- -z1

Z_stat > z1

# Método de p-valor  ---

pvalue <- 2 *(1 - pnorm(Z_stat))
alpha < pvalue

```
Una fábrica fabrica carros con una garantía de 5 años para el motor y la transmisión. Un ingeniero cree que el motor o la transmisión funcionarán mal en menos de 5 años. Hace pruebas con una muestra de 40 coches y encuentra que el tiempo medio es de 4,8 años con una desviación típica de 0,50. (a) Enuncie las hipótesis nula y alternativa. (b) A un nivel de significación del 2%, ¿hay pruebas suficientes que apoyen la idea de que debe revisarse la garantía?

```{r}
# H0: mu >= 5
# H1: mu < 5

y_mu <- 5
y_bar <- 4.8
s <- 0.5
n <- 40
gl = n - 1
confidence <- 0.98
alpha <- 1 - confidence

Z_stat <- (4.8 - 5) / (s/sqrt(n))

# Método de valores críticos ---

z1 <- qnorm(0.98)
Z_stat < - z1

# Método de p-valor  ---

pvalue <-  pnorm(Z_stat)
pvalue < alpha 

```

```{r}
# H0: mu = 0
# H1: mu > 0

y_mu <- 0
y_bar <- 8.2
s <- 23.9
n <- 36
gl = n - 1
confidence <- 0.95
alpha <- 1 - confidence

t_stat <- (y_bar - y_mu) / (s/sqrt(n))

# Método de valores críticos ---

c <- qt(confidence,df = gl)

t_stat > c

# Método de p-valor  ---

pvalue <-  1 - pt(t_stat, df = gl)
pvalue < alpha 

```

```{r}

# single sample
turtle_weights <- c(300, 315, 320, 311, 314, 309, 300, 308, 305, 303, 305, 301, 303)
t.test(x = turtle_weights, mu = 310)

# non paired two sample
sample1 <- c(300, 315, 320, 311, 314, 309, 300, 308, 305, 303, 305, 301, 303)
sample2 <- c(335, 329, 322, 321, 324, 319, 304, 308, 305, 311, 307, 300, 305)

t.test(x = sample1, y = sample2)

#  paired two sample

before <- c(22, 24, 20, 19, 19, 20, 22, 25, 24, 23, 22, 21)
after <- c(23, 25, 20, 24, 18, 22, 23, 28, 24, 25, 24, 20)

t.test(x = before, y = after, paired = TRUE)

```

